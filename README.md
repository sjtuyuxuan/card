# card
关于卡牌覆盖问题的一些思考：

1： 对于DFS的解法我们发现最终需要指数的时间以及空间复杂度， 并不是一种较好的解法。

2：该题在一定程度上存在未定义的情况。 例如，有多条路径同时达到最高层数时对输出哪条并没有明确定义 例如 （100，1），（2，2），（1，1） 可以堆叠两层。但是（100，1），（1，1）与（2，2）（1，1）都是合法路径。

3：可使用动态规划算法获得nlog(n)的时间复杂度以及n的额外空间复杂度
算法如下：

::time nlogn  space n -> 以较长边为key（相等时比较次长边）对卡牌进行递减sort() （较长边为两数中较大的那个，较长边短的不可能覆盖较长边长的卡片）
::time n* space n
对该序列进行遍历 维护一个数组（遍历该卡片后代表到该卡片为止在限制次长边长度为n时的最高层数）（例子：541代表 若选取最终次场边为1最高叠3层，若选取最终次场边为2-4最高叠2层，若选取最终次场边为5最高叠1层，若选取最终次场边大于5最高叠0层）
::time logn  space 1 -> 
若第n张卡牌次长边为 j 则再原数列中寻找 j的位置 由于数组递减（存在重复稍后说明）	只需要二分查找即 logn的复杂度（注意 查找max_index array[index]>=j）。不需要	额外空间
1若查找 得到index == array.size()-1 即查得最后一项 则添加项 j 于末尾
2若查找 得到index ！= array.size()-1 即查得非最后一项 则array[index+1] = j
3若查找 得到index == -1 即j大于所有项 如2即可 array[0]=j
*由于我们将j置于最后一个大于等于j的数据之后 可以确保数组递减

最终返回 array.size()

最终时间复杂度nlogn 空间复杂度 n

例子：
（100，1）（7，2）（5，2）（2，5）（1，3）（3，1）（1，1）
例子本身以及按照最长边进行递减排序
1 √ sortted = （100，1）（7，2）（5，2）（2，5）（1，3）（3，1）（1，1）
2维护数组为：
（100，1）->{1}
（7，2）->{2}
（5，2）->{2,2}
（2，5）->{2,2,2}
（1，3）->{2,2,2,1}
（3，1）->{2,2,2,1,1}
（1，1）->{2,2,2,1,1,1}
最终结果为size-6 若需要输出卡片序列只需要在维护的数组变为pair（int，int） second 储存index即可 例子变为：
（100，1）->{(1,0)}
（7，2）->{(2,1)}
（5，2）->{(2,1),(2,2)}
（2，5）->{(2,1),(2,2),(2,3)}
（1，3）->{(2,1),(2,2),(2,3),(1,4)}
（3，1）->{(2,1),(2,2),(2,3),(1,4),(1,5)}
（1，1）->{(2,1),(2,2),(2,3),(1,4),(1,5),(1,6)}

最终遍历array输出sortte[array[i].second]
时间复杂度与空间复杂度不变 由于一开始使用稳定排序保留了类似（2，5）（5，2）的原生顺序而在动态规划中又没有改变该顺序直接输出即可满足题目需求， 但依然无法规避2中提到的一定程度上存在未定义的情况。
